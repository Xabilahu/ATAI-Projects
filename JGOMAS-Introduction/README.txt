GROUP #3: Xabier Lahuerta Vázquez, Erik Angulo Arnaiz and Oihane Roca García

## TASK 1: SPEAKER Agent (ALLIED) [jasonAgent_ALLIED_T1.asl]

In the initial plan we generate two beliefs, one holding the initial position
(ALLIED base) and the other holding Flag's position.

These positions are consulted using ?my_position and ?objective, for base and
flag's position respectively.

Then, in !perform_look_action, we take agents position, and using the !distance
plan given in jgomas.asl, we calculate distances to base and flag in order to 
print them. !perform_look_action is called very often when agent's state is 
goto_target, so it is convenient for that purpose.

## TASK 2: CRAZY Agent (AXIS) [jasonAgent_AXIS_T2.asl]

 - BASE IMPLEMENTATION:
    We implemented the random position generation inside !update_targets plan, 
    because this plan is called when the agent's state is standing. So, like this,
    we can add a TASK_GOTO_POSITION, the agent will execute it and go back to
    standing state, where another position will be generated.

    The position generation is done by means of .random internal action, which generates
    a random floating point value between [0,1), which then is multiplied by some
    factor in order to get positions between ~ [0,220] (which is close to board size).
    Then those values are checked with the plan !safe_position (which is found in jgomas.asl, 
    which given X, Y and Z, computes the nearest valid position).

 - BUG FIXING: 
    Whenever agents try to go to one position and there is a wall, by default, a new task 
    TASK_WALKING_PATH is generated by internal java implementation (mos likely using A* algorithm),
    in order to find an alternative path which avoids obstacles. 

    There are some times that this java function fails, and agents get stuck in the walls.
    We try to detect when this happens in different ways:
        - We observed that when this happens, sometimes it is because new TASK_WALKING_PATH are
        constantly being added with incremental priorities, reaching +10k priority values. We detect
        these kind of tasks, and recalculate new position to go, so the agent gets unbugged.

        - Sometimes, the agent just gets stuck and there is no TASK_WALKING_PATH being inserted,
        so in order to detect this situation, we compare previous with current positions, if they are
        the same, then the agent is stuck. We calculate a new position, but it sometimes work and some 
        other times it gets stuck... We did not manage to avoid 100% of bugs :(

## TASK 3: FOLLOWER Agent (AXIS) [jasonAgent_AXIS_T{2,3}.asl]

For this task, we needed to modify CRAZY Agent's behaviour, in order to bradcast its position
to the other teammates. This is achieved by using .my_team and .send_msg_with_conversation_id internal 
actions. The first one gets teammates' identifiers and the second one sends them a message.

Then, only in the FOLLOWER Agent, we implemented an answer action for that message, which is just to 
add a new task going to the position indicated in the message.

When the CRAZY Agent dies, the FOLLOWER Agent is stuck in state standing, because he does not receive
messages anymore.

## TASK 4: EXTERMINATOR Agent (ALLIED) [jasonAgent_ALLIED_T4.asl]

In this task the agent will try to identify the crazy agent to kill it. To do so, we first make the agent to go
to the flag position. In the meantime, if it locates the crazy agent it will go to its position to murder him.

To locate crazy agent's position, we will use the agent's FOV objects list. There, we know what the agent is seeing,
including the axis soldiers. For each axis soldier, we will compute the distance between him and the other axis
soldiers it sees. When it finishes computing all the distances, it goes to the axis soldiers that have the
minimun distance between them. That will be achieved by adding a TASK_GOTO_POSITION task with the position 
where they are. It will try to kill the crazy one as it gets closer to them.

## TASK 5: PATROLLER Agent (AXIS) [jasonAgent_AXIS_T5.asl]

For this extra task we implemented an agent that patrols the flag by going in squares around the flag.
In order to do this, we generated an initial belief corresponding to one of the four corners of the square,
and then, depending on which is the following corner, we make the agent go there.

Very simple task, but could not implement any more complex because of the time we already consumed in 
order to get the first 4 task "kind of" working.
